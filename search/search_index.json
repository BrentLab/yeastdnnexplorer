{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"probability_models/generate_binding_effects/","title":"Generate binding effects","text":"<p>Generate binding effects for genes.</p> <p>see generate_perturbation_binding_data() for more details.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If unaffected_lambda or affected_lambda is not non-negative</p> <code>ValueError</code> <p>If signal_group_size is not less than total</p> Source code in <code>yeastdnnexplorer/probability_models/generate_data.py</code> <pre><code>def generate_binding_effects(\n    total: int, signal_group_size: int, unaffected_lambda: float, affected_lambda: float\n) -&gt; torch.Tensor:\n    \"\"\"\n    Generate binding effects for genes.\n\n    see generate_perturbation_binding_data() for more details.\n\n    :raises ValueError: If unaffected_lambda or affected_lambda is not non-negative\n    :raises ValueError: If signal_group_size is not less than total\n\n    \"\"\"\n    if unaffected_lambda &lt; 0 or affected_lambda &lt; 0:\n        raise ValueError(\"Lambda values must be non-negative\")\n    if signal_group_size &gt; total or signal_group_size &lt; 0:\n        raise ValueError(\"Signal group size must be less than total\")\n\n    unaffected_group_size = total - signal_group_size\n\n    unaffected_binding_effect = torch.poisson(\n        torch.full((unaffected_group_size,), unaffected_lambda)\n    )\n    affected_binding_effect = torch.poisson(\n        torch.full((signal_group_size,), affected_lambda)\n    )\n\n    binding_effect = torch.cat((unaffected_binding_effect, affected_binding_effect))\n    return binding_effect\n</code></pre>"},{"location":"probability_models/generate_gene_population/","title":"Generate Gene Population","text":"<p>Generate two sets of genes, one of which will be considered genes which show a signal to both TF binding and response, and the other which does not. The return is a tensor where the first column is the gene/feature identifier (0 to total-1) and the second column is binary indicating whether the gene is in the signal group or not.</p> <p>Parameters:</p> Name Type Description Default <code>total</code> <code>int</code> <p>The total number of genes. defaults to 1000</p> <code>1000</code> <code>signal_group</code> <code>float</code> <p>The proportion of genes in the signal group. defaults to 0.3</p> <code>0.3</code> <p>Returns:</p> Type Description <code>torch.Tensor</code> <p>A tensor where the first column is the gene/feature identifier and the second column is binary indicating whether the gene is in the signal group or not.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if total is not an integer</p> <code>ValueError</code> <p>If signal_group is not between 0 and 1</p> Source code in <code>yeastdnnexplorer/probability_models/generate_data.py</code> <pre><code>def generate_gene_population(\n    total: int = 1000, signal_group: float = 0.3\n) -&gt; torch.Tensor:\n    \"\"\"\n    Generate two sets of genes, one of which will be considered genes which show a\n    signal to both TF binding and response, and the other which does not. The return is\n    a tensor where the first column is the gene/feature identifier (0 to total-1) and\n    the second column is binary indicating whether the gene is in the signal group or\n    not.\n\n    :param total: The total number of genes. defaults to 1000\n    :type total: int, optional\n    :param signal_group: The proportion of genes in the signal group. defaults to 0.3\n    :type signal_group: float, optional\n    :return: A tensor where the first column is the gene/feature identifier and the\n        second column is binary indicating whether the gene is in the signal group or\n        not.\n    :rtype: torch.Tensor\n    :raises ValueError: if total is not an integer\n    :raises ValueError: If signal_group is not between 0 and 1\n\n    \"\"\"\n    if not isinstance(total, int):\n        raise ValueError(\"total must be an integer\")\n    if not 0 &lt;= signal_group &lt;= 1:\n        raise ValueError(\"signal_group must be between 0 and 1\")\n\n    signal_group_size = int(total * signal_group)\n    logger.info(\"Generating %s genes with signal\", signal_group_size)\n\n    # Generating gene identifiers\n    gene_ids = torch.arange(total, dtype=torch.int32)\n\n    # Generating binary labels for signal group\n    labels = torch.cat(\n        (\n            torch.ones(signal_group_size, dtype=torch.int32),\n            torch.zeros(total - signal_group_size, dtype=torch.int32),\n        )\n    )\n\n    # Randomly shuffling labels\n    shuffled_indices = torch.randperm(total)\n    shuffled_labels = labels[shuffled_indices]\n\n    # Combining gene IDs and their labels\n    gene_populations = torch.stack((gene_ids, shuffled_labels), dim=1)\n\n    return gene_populations\n</code></pre>"},{"location":"probability_models/generate_perturbation_binding_data/","title":"Generate perturbation binding data","text":"<p>Using a normal distribution for the perturbation effect, a poisson distribution for the binding effect, simulate the perturbation and binding data. Note that for the perturbation data, the affected and unaffected genes are divided into half where one half has a positive perturbation_mean and the other has a negative perturbation_mean in order to simulate both up and down regulation. Pvalues are calculated from a random distribution based on their effect size, with the assumption that larger effects are less likely to be false positives.</p> <p>Parameters:</p> Name Type Description Default <code>gene_populations</code> <code>Tensor</code> <p>A tensor where the first column is the gene/feature identifier and the second column is binary indicating whether the gene is in the signal group or not. See generate_gene_population() for more details.</p> required <code>unaffected_perturbation_abs_mean</code> <code>float</code> <p>The absolute mean of the perturbation effect for the unaffected genes. defaults to 0.0</p> <code>0.0</code> <code>unaffected_perturbation_std</code> <code>float</code> <p>The standard deviation of the perturbation effect for the unaffected genes. defaults to 1.0</p> <code>1.0</code> <code>affected_perturbation_abs_mean</code> <code>float</code> <p>The absolute mean of the perturbation effect for the affected genes. defaults to 3.0</p> <code>3.0</code> <code>affected_perturbation_std</code> <code>float</code> <p>The standard deviation of the perturbation effect for the affected genes. defaults to 1.0</p> <code>1.0</code> <code>unaffected_binding_lambda</code> <code>float</code> <p>The lambda parameter for the poisson distribution for the unaffected genes. defaults to 1e-3</p> <code>0.001</code> <code>affected_binding_lambda</code> <code>float</code> <p>The lambda parameter for the poisson distribution for the affected genes. defaults to 3.0</p> <code>3.0</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>A dataframe containing the following columns: gene_id: (str) The gene identifier signal: (boolean) Whether the gene is in the signal group or not expression_effect: (float) The perturbation effect expression_pvalue: (float) The pvalue of the perturbation effect binding_effect: (float) The binding effect binding_pvalue: (float) The pvalue of the binding effect</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If gene_populations is not a tensor with two columns where the second column is binary</p> <code>ValueError</code> <p>If unaffected_perturbation_abs_mean is not a float</p> <code>ValueError</code> <p>If unaffected_perturbation_std is not a float</p> <code>ValueError</code> <p>If affected_perturbation_abs_mean is not a float</p> <code>ValueError</code> <p>If affected_perturbation_std is not a float</p> <code>ValueError</code> <p>If unaffected_binding_lambda is not a float or &lt;= 0</p> <code>ValueError</code> <p>If affected_binding_lambda is not a float or &lt;= 0</p> Source code in <code>yeastdnnexplorer/probability_models/generate_data.py</code> <pre><code>def generate_perturbation_binding_data(\n    gene_populations: torch.Tensor,\n    unaffected_perturbation_abs_mean: float = 0.0,\n    unaffected_perturbation_std: float = 1.0,\n    affected_perturbation_abs_mean: float = 3.0,\n    affected_perturbation_std: float = 1.0,\n    unaffected_binding_lambda: float = 1e-3,\n    affected_binding_lambda: float = 3.0,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Using a normal distribution for the perturbation effect, a poisson distribution for\n    the binding effect, simulate the perturbation and binding data. Note that for the\n    perturbation data, the affected and unaffected genes are divided into half where one\n    half has a positive perturbation_mean and the other has a negative perturbation_mean\n    in order to simulate both up and down regulation. Pvalues are calculated from a\n    random distribution based on their effect size, with the assumption that larger\n    effects are less likely to be false positives.\n\n    :param gene_populations: A tensor where the first column is the gene/feature\n        identifier and the second column is binary indicating whether the gene\n        is in the signal group or not. See generate_gene_population() for\n        more details.\n    :type gene_populations: torch.Tensor\n    :param unaffected_perturbation_abs_mean: The absolute mean of the\n        perturbation effect for the unaffected genes. defaults to 0.0\n    :type unaffected_perturbation_abs_mean: float, optional\n    :param unaffected_perturbation_std: The standard deviation of the\n        perturbation effect for the unaffected genes. defaults to 1.0\n    :type unaffected_perturbation_std: float, optional\n    :param affected_perturbation_abs_mean: The absolute mean of the\n        perturbation effect for the affected genes. defaults to 3.0\n    :type affected_perturbation_abs_mean: float, optional\n    :param affected_perturbation_std: The standard deviation of the\n        perturbation effect for the affected genes. defaults to 1.0\n    :type affected_perturbation_std: float, optional\n    :param unaffected_binding_lambda: The lambda parameter for the poisson\n        distribution for the unaffected genes. defaults to 1e-3\n    :type unaffected_binding_lambda: float, optional\n    :param affected_binding_lambda: The lambda parameter for the poisson\n        distribution for the affected genes. defaults to 3.0\n    :type affected_binding_lambda: float, optional\n\n    :return: A dataframe containing the following columns:\n        gene_id: (str) The gene identifier\n        signal: (boolean) Whether the gene is in the signal group or not\n        expression_effect: (float) The perturbation effect\n        expression_pvalue: (float) The pvalue of the perturbation effect\n        binding_effect: (float) The binding effect\n        binding_pvalue: (float) The pvalue of the binding effect\n    :rtype: pd.DataFrame\n\n    :raises ValueError: If gene_populations is not a tensor with two columns\n        where the second column is binary\n    :raises ValueError: If unaffected_perturbation_abs_mean is not a float\n    :raises ValueError: If unaffected_perturbation_std is not a float\n    :raises ValueError: If affected_perturbation_abs_mean is not a float\n    :raises ValueError: If affected_perturbation_std is not a float\n    :raises ValueError: If unaffected_binding_lambda is not a float or &lt;= 0\n    :raises ValueError: If affected_binding_lambda is not a float or &lt;= 0\n\n    \"\"\"\n    # check inputs\n    if not isinstance(gene_populations, torch.Tensor):\n        raise ValueError(\"gene_populations must be a tensor\")\n    if gene_populations.shape[1] != 2:\n        raise ValueError(\"gene_populations must have two columns\")\n    if gene_populations.dtype != torch.int32 and gene_populations.dtype != torch.int64:\n        raise ValueError(\"gene_populations must have torch.int32 or torch.int64 dtype\")\n    if gene_populations.shape[0] == 0:\n        raise ValueError(\"gene_populations must have at least one row\")\n    if not torch.all((gene_populations[:, 1] == 0) | (gene_populations[:, 1] == 1)):\n        raise ValueError(\"gene_populations second column must be binary\")\n    if not isinstance(unaffected_perturbation_abs_mean, float):\n        raise ValueError(\"unaffected_perturbation_abs_mean must be a float\")\n    if not isinstance(unaffected_perturbation_std, float):\n        raise ValueError(\"unaffected_perturbation_std must be a float\")\n    if not isinstance(affected_perturbation_abs_mean, float):\n        raise ValueError(\"affected_perturbation_abs_mean must be a float\")\n    if not isinstance(affected_perturbation_std, float):\n        raise ValueError(\"affected_perturbation_std must be a float\")\n    if not isinstance(unaffected_binding_lambda, float):\n        raise ValueError(\"unaffected_binding_lambda must be a float\")\n    if unaffected_binding_lambda &lt;= 0:\n        raise ValueError(\"unaffected_binding_lambda must be &gt; 0\")\n    if not isinstance(affected_binding_lambda, float):\n        raise ValueError(\"affected_binding_lambda must be a float\")\n    if affected_binding_lambda &lt;= 0:\n        raise ValueError(\"affected_binding_lambda must be &gt; 0\")\n\n    total = gene_populations.shape[0]\n    signal_group_size = torch.sum(gene_populations[:, 1]).item()\n\n    # Generate effects\n    perturbation_effect = generate_perturbation_effects(\n        total,\n        signal_group_size,\n        unaffected_perturbation_abs_mean,\n        unaffected_perturbation_std,\n        affected_perturbation_abs_mean,\n        affected_perturbation_std,\n    )\n    binding_effect = generate_binding_effects(\n        total, signal_group_size, unaffected_binding_lambda, affected_binding_lambda\n    )\n\n    # Generate p-values\n    perturbation_pvalues = generate_pvalues(perturbation_effect)\n    binding_pvalues = generate_pvalues(binding_effect)\n\n    # Combine into DataFrame and return\n    df = pd.DataFrame(\n        {\n            \"gene_id\": gene_populations[:, 0].numpy(),\n            \"signal\": gene_populations[:, 1].numpy().astype(bool),\n            \"expression_effect\": perturbation_effect.numpy(),\n            \"expression_pvalue\": perturbation_pvalues.numpy(),\n            \"binding_effect\": binding_effect.numpy(),\n            \"binding_pvalue\": binding_pvalues.numpy(),\n        }\n    )\n\n    return df\n</code></pre>"},{"location":"probability_models/generate_perturbation_effects/","title":"Generate perturbation effects","text":"<p>Generate perturbation effects for genes.</p> <p>See generate_perturbation_binding_data() for more details.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If signal_group_size is not less than total</p> Source code in <code>yeastdnnexplorer/probability_models/generate_data.py</code> <pre><code>def generate_perturbation_effects(\n    total: int,\n    signal_group_size: int,\n    unaffected_mean: float,\n    unaffected_std: float,\n    affected_mean: float,\n    affected_std: float,\n) -&gt; torch.Tensor:\n    \"\"\"\n    Generate perturbation effects for genes.\n\n    See generate_perturbation_binding_data() for more details.\n\n    :raises ValueError: If signal_group_size is not less than total\n\n    \"\"\"\n    if signal_group_size &gt; total:\n        raise ValueError(\"Signal group size must not exceed total\")\n\n    unaffected_group_size = total - signal_group_size\n\n    unaffected_perturbation_effect = torch.cat(\n        (\n            torch.normal(\n                unaffected_mean, unaffected_std, size=(unaffected_group_size // 2,)\n            ),\n            torch.normal(\n                -unaffected_mean, unaffected_std, size=(unaffected_group_size // 2,)\n            ),\n        )\n    )\n\n    affected_perturbation_effect = torch.cat(\n        (\n            torch.normal(affected_mean, affected_std, size=(signal_group_size // 2,)),\n            torch.normal(-affected_mean, affected_std, size=(signal_group_size // 2,)),\n        )\n    )\n\n    perturbation_effect = torch.cat(\n        (unaffected_perturbation_effect, affected_perturbation_effect)\n    )\n    return perturbation_effect\n</code></pre>"},{"location":"probability_models/generate_pvalues/","title":"Generate pvalues","text":"<p>Generate p-values for genes where larger effects are less likely to be false positives.</p> <p>Parameters:</p> Name Type Description Default <code>effects</code> <code>Tensor</code> <p>A tensor of effects</p> required <code>large_effect_percentile</code> <code>float</code> <p>The percentile of effects that are considered large effects. Defaults to 0.9</p> <code>0.9</code> <code>large_effect_upper_pval</code> <code>float</code> <p>The upper bound of the p-values for large effects. Defaults to 0.2</p> <code>0.2</code> <p>Returns:</p> Type Description <code>torch.Tensor</code> <p>A tensor of p-values</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If effects is not a tensor or the values themselves are not numeric</p> <code>ValueError</code> <p>If large_effect_percentile is not between 0 and 1</p> <code>ValueError</code> <p>If large_effect_upper_pval is not between 0 and 1</p> Source code in <code>yeastdnnexplorer/probability_models/generate_data.py</code> <pre><code>def generate_pvalues(\n    effects: torch.Tensor,\n    large_effect_percentile: float = 0.9,\n    large_effect_upper_pval: float = 0.2,\n) -&gt; torch.Tensor:\n    \"\"\"\n    Generate p-values for genes where larger effects are less likely to be false\n    positives.\n\n    :param effects: A tensor of effects\n    :type effects: torch.Tensor\n    :param large_effect_percentile: The percentile of effects that are considered large\n        effects. Defaults to 0.9\n    :type large_effect_percentile: float, optional\n    :param large_effect_upper_pval: The upper bound of the p-values for large effects.\n        Defaults to 0.2\n    :return: A tensor of p-values\n    :rtype: torch.Tensor\n    :raises ValueError: If effects is not a tensor or the values themselves are not\n        numeric\n    :raises ValueError: If large_effect_percentile is not between 0 and 1\n    :raises ValueError: If large_effect_upper_pval is not between 0 and 1\n\n    \"\"\"\n    # check inputs\n    if not isinstance(effects, torch.Tensor):\n        raise ValueError(\"effects must be a tensor\")\n    if not torch.is_floating_point(effects):\n        raise ValueError(\"effects must be numeric\")\n    if not 0 &lt;= large_effect_percentile &lt;= 1:\n        raise ValueError(\"large_effect_percentile must be between 0 and 1\")\n    if not 0 &lt;= large_effect_upper_pval &lt;= 1:\n        raise ValueError(\"large_effect_upper_pval must be between 0 and 1\")\n\n    # Generate p-values\n    pvalues = torch.rand(effects.shape[0])\n\n    # Draw p-values from a uniform distribution where larger abs(effects) are\n    # less likely to be false positives\n    large_effect_threshold = torch.quantile(torch.abs(effects), large_effect_percentile)\n    large_effect_mask = torch.abs(effects) &gt;= large_effect_threshold\n    pvalues[large_effect_mask] = (\n        torch.rand(torch.sum(large_effect_mask)) * large_effect_upper_pval\n    )\n\n    return pvalues\n</code></pre>"},{"location":"tutorials/generate_in_silico_data/","title":"Generate in silico data","text":"<pre><code>from yeastdnnexplorer.probability_models.generate_data import (generate_gene_population, \n                                                               generate_perturbation_binding_data)\n\n</code></pre> <pre><code># generate a population of 1000 genes with 30% of them labelled 1 (signal)\n# and 0 (noise)\n# note that 1000 and 0.3 are the default values for this function\npopulation1 = generate_gene_population(1000, 0.3)\n\npopulation1\n</code></pre> <pre>\n<code>tensor([[  0,   0],\n        [  1,   1],\n        [  2,   0],\n        ...,\n        [997,   1],\n        [998,   0],\n        [999,   1]], dtype=torch.int32)</code>\n</pre> <pre><code># generate perturbation and binding data based on this population\n# note that these are the default values for this function\npopulation1_tf1_data = generate_perturbation_binding_data(\n    population1,\n    0.0, 1.0,\n    3.0, 1.0,\n    1e-3,\n    0.5)\n\n# label this with an arbitrary TF name\npopulation1_tf1_data['regulator'] = 'TF1'\n\npopulation1_tf1_data\n</code></pre> gene_id signal expression_effect expression_pvalue binding_effect binding_pvalue regulator 0 0 False 0.586505 0.490923 0.0 0.617704 TF1 1 1 True -1.804174 0.812814 0.0 0.931650 TF1 2 2 False -1.711246 0.796702 0.0 0.092472 TF1 3 3 False 0.216889 0.134506 0.0 0.586258 TF1 4 4 False 1.477974 0.571152 0.0 0.566378 TF1 ... ... ... ... ... ... ... ... 995 995 False -3.208976 0.586691 1.0 0.157508 TF1 996 996 True -2.431389 0.939327 0.0 0.661516 TF1 997 997 True -2.818533 0.319082 0.0 0.117773 TF1 998 998 False -1.859800 0.733280 0.0 0.606050 TF1 999 999 True -1.996819 0.420980 0.0 0.649173 TF1 <p>1000 rows \u00d7 7 columns</p>"}]}